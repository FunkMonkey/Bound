\chapter{Language Binding}

The term ''language binding'' refers to the process\todo{Word} of exposing functionality written in one programming language, so it can be used from within a different programming language\todo{and verse visa} - for example exposing C++ functions for use in Python.

The need to combine different programming languages and exchange information between those may arise due to several reasons. A specific language may support a different set of programming paradigms and thus be better suited for solving a special group of tasks. A project may also rely on a 3rd party library written in another language. In general, software-reuse is a common reason for binding multiple languages together.

Often, language binding is needed to connect a higher-level programming language (f. ex. a scripting language like Python) with a lower-level programming language (f. ex. a system programming language like C).

\section{System programming languages and scripting languages}

Speaking of language binding, there is a set of terms that need explanation.\todo{rewrite}

\todo{References to Ousterhout}The terms ''low(er)-level'' and ''high(er)-level'' refer to the degree of abstraction a programming language provides in comparison to another language. Higher-level languages encapsulate more machine instructions per statement and thus usually need less code to be written to perform a given task, by handling machine-oriented details like register allocation automatically and omitting complexity\todo{rewrite}. This leads to better code-maintainability and faster development at the cost of performance. 

John Ousterhout, the creator of the scripting language TCL, describes a \textbf{system programming language} as a strongly (statically) typed language designed to create applications from scratch, but offering a higher level of abstraction in doing so compared to assembly programming languages, which are considered very low-level.

\textbf{Scripting languages}, on the other hand, represent a very different style of programming than system programming languages. They ''assume that there already exists a collection of useful components written in other languages [...] and are intended primarily for plugging together components'' \todo{Quote}. They offer a higher level of abstraction compared to system programming languages, f. ex. by using dynamic typing, thus sacrificing execution speed to improve development speed.\todo{code-reuse?}\\ Being mostly interpreted languages, they support faster development and rapid prototyping by eliminating compile- and link-time. Interpretation also offers better portability as well as a great deal of flexibility by allowing run-time code-manipulation. Due to their simpler syntax, scripting languages are usually easier to learn.

Scripting and system programming languages are symbiotic. System programming languages are used to create high-performance components providing platform-access\todo{rewrite}, which can then be assembled using scripting languages.\todo{Quote??} Binding a system programming language and a scripting language together provides the advantages of both worlds\todo{types?}.

\todo{Software-Reuse, OS-API and access, native, host, guest, extending, embedding, pipe-example}

\section{Types of function binding}

Before the process of binding different languages into one application is explained, it is important to define some terms concerning the binding of functions.

Static or ''early'' binding means that ''the compiler generates a call to a specific function name, and the linker resolves this call to the absolute address of the code to be executed.'' \todo{thinking c++}

Dynamic binding, dynamic dispatch or ''late'' binding, on the opposite side, refers to resolving the address of the code to be called dynamically at run-time. This can be done in various ways, and the definitions in literature and internet vary extremely at this point.

Looking at C++, calls to virtual functions are bound at run-time, as the compiler is unable to know which implementation a base class reference may point to and thus which function to call. Every class containing virtual functions has run-time type information (RTTI) for retrieving the correct implementation. Still the compiler is able to do static type checking and can do optimizations to increase the performance of the lookup. In any case there needs to be compile-time-knowledge about the interface / base class of the object. 

Looking up the address of a function at run-time using a string or other type of identifier is also a kind of dynamic binding. The lookup may still make use of the RTTI in a manual way. Information about parameters and return types may also be needed to looked up. Type checking has to be done at run-time, but therefore no compile-time-knowledge about the interface is needed.

Concerning performance, static binding is the fastest. Due to compiler optimization and static type checking, dynamic binding using RTTI is faster than lookup using an identifier. In contexts outside of standard C++, dynamic binding using RTTI is still sometimes referred to as ''early'' binding, due to its performance advantage compared to lookup using an identifier.

It is important to understand that static binding is only possible in programming languages that support static typing. Scripting languages like JavaScript, where variables are weakly typed, can not know the type of a variable at compilation-time and thus can only use dynamic binding.

\section{The process of binding languages}

\begin{quotation}
Binding one language to another is a non-trivial task. The binding language needs to understand the calling conventions, type system, data structures, memory allocation mechanisms and linking strategy of the target language, just to get things working. The task is to carefully align the semantics of both languages, so that both languages can understand the data that passes between them.
\end{quotation}\todo{Real World Haskellby Bryan O'Sullivan, Don Stewart, and John Goerzen}

When binding a scripting language to a system programming language, the scripting language usually comes in form of a library exposing an interface that can be used from the system programming language to interact with the scripting language.\\
The code written to bind both languages together is often referred to as ''glue code'' or ''foreign interface''. The process of creating such code is called ''wrapping''.

\begin{quotation}
A foreign interface is a piece of glue code, intended to make it possible to use functionality written in one language (often C) available to programs written in another (usually high-level) language. Such glue code involves low-level details that users of high-level languages usually take for granted. For example:
\begin{itemize}
\item marshalling objects to and from foreign code,
\item managing memory and other resources,
\item dealing with different calling conventions, implicit function arguments, etc.
\end{itemize}
\end{quotation}

\textbf{Foreign interfaces} can be either static or dynamic.\\
\textbf{Static foreign interfaces} are written and compiled in the system programming language using the API the scripting language provides.\\
\textbf{Dynamic foreign interfaces} are created at run-time. This can be done in two ways:
\begin{itemize}
\item writing glue code in the system programming language using the scripting languages API \textbf{in conjunction} with dynamic method invocation
\item writing glue code in the scripting language itself using the scripting languages dynamic \textbf{foreign function interface} (FFI)
\end{itemize}

The terminology concerning foreign \textbf{function} interfaces (FFIs) is somewhat confusing. This thesis will use the following definition:

\begin{quotation}
A foreign function interface is originally a lisp term for dynamically defining and calling functions in outside shared libraries (''foreign function'', ''call-out') and as additional option also creating functions which can be called from outside functions (''callback'', ''foreign-callable'', ''call-in'').
\end{quotation}\todo{Urban, Design Issues for Foreign Function Interfaces}

To express the dynamic nature of the given definition, this thesis will stick to the term ''\textbf{dynamic} foreign function interface''.

The different ways of creating foreign interfaces will be explained in more detail in the following sections.

\newpage
\subsection{Static foreign interfaces}

Both Python and Mozilla's JavaScript implementation Spidermonkey are accessible in form of a library exposing a C-API. Thus glue code for binding C or C++ functionality to one of these languages has to be written in C / C++ using the given API.

\begin{lstlisting}[language=C++, caption=Exposing a C function to Spidermonkey (taken from MDN)]
// A simple JS wrapper for the rand() function from the C standard library
JSBool myjs_rand(JSContext *cx, uintN argc, jsval *vp)
{
    // setting the result of rand() as the return value
    JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(rand()));
    return JS_TRUE;
}

// ... somewhere in the code: defining the function on the global object
// so it can be used from the script
JSFunctionSpec myjs_global_functions[] = {
    JS_FS("rand",   myjs_rand,   0, 0),
    JS_FS_END
};

JS_DefineFunctions(cx, global, myjs_global_functions);
\end{lstlisting}
\todo{Reference to MDN}

\begin{lstlisting}[language=JavaScript, caption=Using a C function from SpiderMonkey]
var r = rand();	// r is a random number
\end{lstlisting}

The glue code is responsible for converting between the types of the system programming language and the scripting language for arguments and return value, as well as calling the wrapped function in between. When converting arguments from script types to the expected types of the function, type-checking needs to be performed. This happens at run-time as the number and types of arguments (stored in in \textbf{argc} and \textbf{vp}) passed to this wrapper function is not known at compile-time.

The \textit{call of the native function} \textbf{rand} itself uses static binding or when working with virtual classes (for calling methods) dynamic binding using RTTI. As JavaScript itself is a weakly typed language, the \textit{call to the wrapper function} \textbf{myjs\_rand} itself is in fact dynamically bound and its address looked up using the string ''rand''.

Looking at the given example, it is obvious that even the wrapping of a simple C function that does nothing but return a double value without taking any argument, requires a \todo{nicht zu unterschätzen} amount of glue code, which is most-likely error-prone and hard to maintain.

Thus, the purpose of this thesis is to develop an application that automatically creates glue code for different scripting languages.\todo{special color}

\subsection{Dynamic foreign interfaces and dynamic method invocation}

When wrapping a class, instead of writing glue code for every single function, it is also possible to direct every call through a single proxy function that does all the work at run-time. This is a form of dynamic dispatch, thus such a function can be called a ''dispatch function''. \todo{check}\\

Consider a script object that wraps a class instance. The object internally holds a reference to the wrapped instance. When calling a method of the given object, f. ex. ''doSomething'', the call will be directed to the proxy function. Based on the given string ''doSomething'' and the internal instance, the proxy will look up the memory address and expected parameters of the native function, convert the given script-arguments to the expected format, call the native function (dynamic invocation) and convert the return value to a type that is understood by the scripting language - all at run-time.

The lookup of native functions may be trivial for programming languages that support reflection\todo{explain reflection}, like C\# or Java, where the language provides ways of calling functions using a string-identifier.\\
A language like C++, which does not support reflection, needs special type libraries\todo{explain typelib}, which map the string-identifiers (''doSomething'') to the according position (offset) of the function in the classes virtual table\todo{explain vtable}. Knowing the offset, the memory address of the function can be retrieved, so it can be called.

Compared to writing glue code for every function, where the memory addresses are often known at compile-time (static binding) or looked up via RTTI, dynamic method invocation has several downsides. Method addresses and parameter information need to be looked up and type checking needs to be done at run-time which costs performance. As lookup happens at run-time, dynamic invocation has the advantage, that type information of the wrapped classes is not needed at compile-time of the code that handles the binding (proxy function).

\subsection{Dynamic foreign function interfaces}

Some scripting languages allow the use of public symbols from shared libraries, such as calling functions and accessing data types, without the need to write glue code in the system programming language. The scripting language provides an API (the dynamic foreign function interface) for writing the glue code in the scripting language itself.

Such APIs are available in a multitude of programming languages such as Lisp and Haskell. One of the most prominent examples is Pythons foreign function library ''ctypes''. Mozilla developed an equivalent for SpiderMonkey called ''js-ctypes''. Besides the Java Native Interface (JNI), which is part static and part dynamic, there is a completely dynamic foreign function interface for Java called Java Native Access (JNA). \todo{reference}

These APIs provide equivalents for basic C types like numbers and pointers. Complex data types like structs need to be composited on the scripting side using the given types. C functions can be accessed using the string representation of their name.

\todo{Example}

Due to the complexity of the data structures and the non-standardized name mangling (the creation of unique names for functions for symbol export) in C++, most FFIs are only able to access libraries that use basic C types, plain old data (POD) structures and C name mangling.

As a side note, most FFI implementations use the same library, \textbf{libffi}\todo{link}, for handling the common low level tasks.

\section{Existing language binding systems and tools}

As the need for connecting different programming languages arises in many projects - especially in the computer games industry the embedding of scripting languages is very popular - there are already systems and tools existing for automating the binding-process, creating glue code or providing dynamic access to native code. Some will be explained in further detail.

\subsection{Component models}

\begin{quotation}
Component-based software engineering is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems.
\end{quotation}\todo{Sommerville}

A software component itself is an independent piece of software that encapsulates discrete functionality into a reusable entity to be used in composition with other components. \todo{from component thesis}.

Such components need to conform to component standards, which ''are embodied in a component model and define [...] how component interfaces should be specified and how components communicate.''\todo{Sommerville} They also standardize facets like memory management, exception- and error-handling as well as metadata for runtime type information.\todo{from component thesis}

Prominent examples of such component models (standards and middleware) are the Object Management Group's (OMG) Common Object Request Broker Architecture (CORBA) and Microsoft's Component Object Model (COM). Mozilla uses a cross-platform variant of COM called XPCOM inside its products.

These component models are language-agnostic, meaning that components can be written in and used from a multitude of different programming languages. The process of binding the languages together and letting objects written in different languages communicate with each other is handled by the middleware.

\subsection{Interfaces}

\begin{quotation}
The services offered by a component are made available through an interface, and all interactions are through that interface.
\end{quotation}\todo{Sommerville}

CORBA, COM and XPCOM are strictly separating interfaces and implementations. The same interface can be implemented by multiple classes and a class can also implement multiple interfaces.

Interfaces are defined in a special interface definition language (IDL). These interface files are used in different ways.\\
When implementing COM or CORBA components in C++, an IDL compiler is used to create header files with abstract classes that are to be extended and implemented.\\
The IDL compiler will also create type libraries which hold information about the interfaces, the functions and their offsets in the virtual table, their parameters, etc. When calling a components method from a dynamically typed scripting language, these type libraries will be used for dynamically invoking the method by its name at run-time as described in section XXX. \todo{link} In COM, statically typed or compiled languages like Visual Basic also use the type libraries for retrieving function memory addresses at compile-time to eliminate the cost of dynamic method invocation.

\subsection{Communication between components}

When it comes to in-process communication between different components and objects, COM and CORBA go different ways. 

Components written in COM have to follow a binary standard, meaning they have to share the same layout in memory for a given interface, no matter in which language they are implemented. Not all programming languages support COMs binary standard, thus there is only a set of languages COM components can be written in, though a broader set they can be used from.

CORBA on the other hand standardizes the IDL as well as the language bindings. All calls are routed through the Object Request Broker, which is responsible for translating the calls and converting arguments. ''By mandating the use of runtime software for all object invocations, CORBA can effectively hide differences between communicating objects — what languages they are written in, on what machines they are running and the operating system used — without requiring that their interfaces all look the same in memory. Thus, CORBA is, unlike COM, not a binary standard.''\todo{compo thesis}

When using objects from a weakly typed scripting language, neither CORBA nor COM are producing glue code for binding purposes but handle function calls and type-checking at run-time using dynamic binding with lookup using identifiers (dynamic method invocation). Thus calls to such an object from script are dynamically bound twice. First the address of the handler-function needs to be looked up, then the handler needs to look up the address and parameter information of the function to call. This is a performance overhead compared to compiled glue code that uses static binding.

Component models and the according middleware have the advantage of handling the communication between the different languages under the hood, so there is no need for the programmer to write glue code that deals with argument conversion or memory management issues.\\
On the downside, when wrapping C++, the wrapped classes need to inherit from the given interfaces or in the case of COM at least conform to the binary layout of the interface. Already existing libraries can thus not be wrapped without modification or creation of a wrapper-library that conforms to the component standard.

Component models like COM and CORBA provide many more features than just language-agnosticism and inter-language communication. CORBA and DCOM, the distributed version of COM, also provide support for handling inter-process and inter-machine communication, hiding the complexity of remote calls from the user. These architectures thus come with an overhead, which may be unacceptable when all the user wants to do is to bind two programming languages.

\todo{Non-Goal need to include interfaces}

.\\
.\\
\todo{TODO-List}
  - late binding!!!
  - Erzeugung von Komponenten in welcher Sprache? Richtung der Aufrufe ...
  - Welche Systeme / Methoden / Tools gibt es schon um Language-Binding zu vereinfachen / automatisieren (COM, Corba, Mozilla XPCOM + IDL, SWIG)
  - Warum wird ein eigenes Tool entwickelt? (Notwendigkeit, Vorteile, Goals- und Non-Goals, etc.)
  - Wie soll die Automatisierung grob erfolgen? -> Übergang zu Static Analysis