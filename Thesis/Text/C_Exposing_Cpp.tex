\chapter{Binding C++ and Spidermonkey}\todo{properName}
\label{chap:LanguageBindingCPPJS}

This chapter shows how \myProperName{C++} elements like declarations and types can be exposed to \myProperName{Mozilla Spidermonkey} to be used from scripts. \myProperName{Spidermonkey} is the name of \myProperName{Mozilla}'s implementation of the \myProperName{ECMAScript} programming language standard, which is most commonly known as \myProperName{JavaScript}. The terms \myProperName{JavaScript} and \myProperName{ECMAScript} will be used interchangebly, whereas \myProperName{Spidermonkey} refers to the concrete \myProperName{Mozilla} implementation.\\
Binding \myProperName{C++} elements to other programming languages like \myProperName{Python} or \myProperName{Lua} or other \myProperName{JavaScript} implementations, e.g. \myProperName{V8}\footnote{\url{http://code.google.com/p/v8/}}, will be similar in many aspects - depending on the elements existing in the target language.

The information in this chapter presumes knowledge about the \myProperName{C++} programming language, its elements, class-based inheritance and type system.

\section{\myProperName{JavaScript}/\myProperName{ECMAScript}}
\label{sec:JavaScript}

\myProperName{JavaScript} is a weakly typed object-oriented programming language with automatic garbage collection. 

As it is a feature-rich language, only the most important aspects will be presented in this section. More information can be found in \myProperName{Mozilla}'s \myProperName{JavaScript} guide\footnote{\url{https://developer.mozilla.org/en/JavaScript/Guide}} or in various books like \myAuthorName{David Flanagan}'s \myBookName{JavaScript: The Definite Guide} or \myAuthorName{Douglas Crockford}'s \myBookName{JavaScript: The Good Parts}.

There are 6 basic types that a value can be of: boolean, number, string, \mySCName{undefined}, \mySCName{null} and object.\\
Number, string, and boolean are primitive types. So are \mySCName{null} and \mySCName{undefined}, which both represent the absence of value. All are immutable.\\
Objects are basically mutable collections of name-value-pairs, known as properties or \mySlang{members}. They can be seen as hash-maps or associative arrays. Object properties can be accessed using bracket-syntax (e.g. \mySCName{var foo["bar"] = 3;}) or dot-notation (e.g. \mySCName{var foo.bar = 3;}). An \mySCName{Array} is a special type of \myProperName{JavaScript} object.\\
Functions are special objects that have source code associated and thus can be invoked. Being objects, functions can have properties and can even be passed as parameters.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Types in \myProperName{JavaScript}]
// primitive types
var aNumber = 34.9;
var aBoolean = true;
var aString = "Some text!";
var aNullValue = null;
var anUndefinedValue; // standard type for variables that have 
                      // no value assigned
var anotherUndefinedValue = undefined;

// object types
var anObject = {};
anObject.foo = "bar";
anObject.subObject = { foo: "bar"};

var anArray = [];

function aFunction(param)
{
	return param * 3;
}

aFunction.someProperty = "Functions are objects, too!";
\end{lstlisting}
\OnehalfSpacing

When being passed as parameters or assigned to variables, primitive values are passed by value / copy-assigned, whereas objects (including functions) are passed/assigned by reference.\\
\myProperName{JavaScript} thus has no notion of pointers and changes made to primitive values passed as function parameters will not have any effect on the original value.

There are two kinds of properties: value properties and accessor properties. A value property simply contains any type of value (e.g. a number or function). Accessor properties have a getter and setter function associated that can perform additional computation when getting or setting a value. They are used just like normal data properties.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Types in \myProperName{JavaScript}, label=JSTypes]
var obj = {
	// value properties
	aValue: 3,
	aValue_Function: function(){ this.aValue *= 2; },
	
	// an accessor property
	get accessorProp(){ return this.aValue + 3; },
	set accessorProp(val){ this.aValue = val - 3; }
};

obj.aValue = 4;        // --> obj.aValue is 4
obj.aValue_Function(); // --> obj.aValue is 8
obj.accessorProp = 6;  // --> obj.aValue is 3 (6-3)
\end{lstlisting}
\OnehalfSpacing

Functions like \mySCName{aValue\_Function} in \myRefListing{JSTypes} do not strictly belong to the object they are declared on. Their execution context (which can be referred to using \mySCName{this} inside the function) is determined at run-time and usually refers the object through which the function is called. With the help of a function object's \mySCName{call} function, an execution context can be forced.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Execution context of functions]
// obj1 declares the function
var obj1 = {
	name: "Paul",
	sayHello: function (){ return "Hello, I am " + this.name; }
}

// obj2 borrows the function (and additionally renames it)
var obj2 = {};
obj2.name = "John";
obj2.sayHello_renamed = obj1.sayHello; 

var obj3 = { name: "Ringo" };

obj1.sayHello();          // --> "Hello, I am Paul"
obj2.sayHello_Renamed();  // --> "Hello, I am John"

// forcing the execution context
obj1.sayHello.call(obj3); // --> "Hello, I am Ringo"

\end{lstlisting}
\OnehalfSpacing

\subsection{Inheritance}

The prototypical inheritance mechanism used in \myProperName{JavaScript} vastly differs from class-based inheritance known from \myProperName{C++} and \myProperName{Java}. In a class-based inheritance the class defines a design contract that created instances adhere too.\\
\myProperName{JavaScript} uses prototypes instead. A prototype is a normal \myProperName{JavaScript} object from which other objects inherit the properties. When a property is looked up on an object, the object is checked if it does have an own property with the name. If not, its prototype is checked for the property. If this doesn't have it either, the prototype's prototype is checked on so on. This is also called the prototype chain.\\
The prototype of an object is saved as an internal property ([[Prototype]]) that can not be set after object creation and can only be accessed using \linebreak\mySCName{Object.getPrototypeOf(anObject)}.\\
If a property with the same name is set on an object that has a prototype, then it shadows the prototype's property.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Prototypes]
var aPrototype = { aProp: "Prop of prototype" };
aPrototype.aProp; // --> "Prop of prototype"

// creating an object with aPrototype as the prototype
var anInstance = Object.create(aPrototype);
Object.getPrototypeOf(anInstance) == aPrototype // --> true

anInstance.aProp; // --> "Prop of prototype"

// shadowing
anInstance.aProp = "Prop of instance";
anInstance.aProp; // --> "Prop of instance"
\end{lstlisting}
\OnehalfSpacing

\subsubsection{Classes}

Classes can be mimicked in \myProperName{JavaScript} with the help of constructor functions. Whenever a function is called with the \mySCName{new} operator, a new object (instance) is created. This object's internal [[Prototype]] property is set to the \mySCName{prototype} property of the function. These two are not to be confused. The \mySCName{this} keyword will refer to the created instance and can be used to define properties on the instance, for example \mySCName{name} in \myRefListing{JSClasses}. The \mySCName{sayHello} function will be shared by all instances, as it is defined on the prototype, whereas \mySCName{name} only exists on the instances themselves.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Classes in \myProperName{JavaScript}, label=JSClasses]
function Person(name)
{
	this.name = name;
}

Person.prototype.sayHello = function()
{
	return "Hi, my name is (what?), my name is " + this.name;
}

var anInstance = new Person("Slim Shady");
anInstance.sayHello();
// --> "Hi, my name is (what?), my name is Slim Shady"
\end{lstlisting}
\OnehalfSpacing

For creating inheritance chains, the internal [[Prototype]] property of a function's \linebreak\mySCName{prototype} object must reference another function's \mySCName{prototype} object. If a base constructor function initializes members, then it must be called explicitly from the subclass constructor function with the help of the function object's \mySCName{call} function.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Prototype-based inheritance in \myProperName{JavaScript}, label=JSClasses]
function Base()
{
	this.baseMember = 3;
}

Base.prototype.doSomething = function(){ return this.baseMember * 3;}

function SubClass()
{
	// call Base constructor with call (and without new)
	Base.call(this);
	this.subclassMember = "Another member";
}

// assigning a new prototype object with [[Prototype]] Base
SubClass.prototype = Object.create(Base);
// resetting the constructor property
SubClass.prototype.constructor = SubClass;

var instance = new SubClass();
instance.doSomething(); // --> 9 (3 * 3)

\end{lstlisting}
\OnehalfSpacing

\todo{proto chain illustration}

\subsubsection{Mixins}

Multiple inheritance is not supported in \myProperName{JavaScript}, but can be mimicked to a certain degree by borrowing functions. This concept is also called \textbf{mixin}.

\SingleSpacing
\begin{lstlisting}[language=JavaScript, caption=Mixins in \myProperName{JavaScript}, label=JSMixins]
function BaseA(){}
BaseA.prototype.funcA = function(){}

function BaseB(){}
BaseB.prototype.funcB = function(){}

function SubClass()
{
	BaseA.call(this);
	BaseB.call(this);
}

// borrowing functions / mixing in
SubClass.prototype.funcA = BaseA.prototype.funcA;
SubClass.prototype.funcB = BaseB.prototype.funcB;

// creating an instance
var instance = new SubClass();
instance.funcA();
instance.funcB();
\end{lstlisting}
\OnehalfSpacing

\section{\myProperName{Spidermonkey}}

Spidermonkey comes in form of a shared library exposing a \myProperName{C} API that can be used to interact with the \myProperName{JavaScript} interpreter. This API is also known as \myProperName{JSAPI}. 

A \mySCName{JSRuntime} is an instance of the virtual machine. A \mySCName{JSContext} is a is a single world within a \mySCName{JSRuntime}, in which all objects and values live. One \mySCName{JSRuntime} can have multiple \mySCName{JSContext}s. Each context has a global object. Objects are exposed as \mySCName{JSObject}.

A \myProperName{JavaScript} value is expressed as a \mySCName{jsval}. \mySCName{jsval} contains information about the type of the value (number, boolean, etc.). For strings and objects, the \mySCName{jsval} stores the pointer to the \mySCName{JSString} or \mySCName{JSObject}. For all other types, the data is saved in the \mySCName{jsval} itself. \mySCName{jsval}s occur at several places in \myProperName{JSAPI}, for example when defining properties, for parameter values or return values.\\
\myProperName{Spidermonkey} provides utility macros/functions for retrieving the type of a \mySCName{jsval} \linebreak(e.g. \mySCName{JSVAL\_IS\_OBJECT}) and its content (e.g. \mySCName{JSVAL\_TO\_OBJECT}) or for creating \mySCName{jsval}s from the according \myProperName{Spidermonkey} \myProperName{C++} types (e.g. \mySCName{OBJECT\_TO\_JSVAL}).\\
When converting between \mySCName{jsval}s and \myProperName{C++} types, type checking needs to be performed. The \myProperName{C++} compiler that compiles the glue code will perform this task, when converting \textbf{to} \mySCName{jsval}, as the conversion functions only accept the correct type. When converting a \mySCName{jsval} to a \myProperName{C++} type, the current type of the \mySCName{jsval} needs to be checked first. If the \myProperName{JSAPI} user for example tries to retrieve a \mySCName{JSObject} from a \mySCName{jsval} that contains a boolean value, the behaviour of the code is undefined and will probably lead to a run-time failure like a crash. Thus type checking and error handling play an important role and are explained in further detail in \myRefSection{sec:ErrorHandling}.\\
\myProperName{Spidermonkey} also provides utility functions for automatic conversion of types according to the \myProperName{ECMAScript} standard. If, for example, a boolean is passed to a function that expects a string, the conversion would create a string from the boolean - either \mySCString{true} or \mySCString{false}. These conversion functions are less performant, but allow for a greater range of values without reporting errors. It has to be said though, that automatic conversion can lead to unexpected program behaviour in places where the user would expect an error.\\
Most of the conversion functions take a \mySCName{JSContext} as the parameter.

A \mySCName{JSObject} has a \mySCName{void} pointer that \myProperName{JSAPI} users can use for storing any kind of private data. This will be useful for storing pointers of \myProperName{C++} classes.

\section{Boolean values}

Boolean values can be converted between \mySCName{jsval}s and the \myProperName{C++} boolean type using \mySCName{JSVAL\_TO\_BOOLEAN} and \mySCName{BOOLEAN\_TO\_JSVAL}. \mySCName{JS\_ValueToBoolean} can be used for automatic conversion. If the function returns false, the given \mySCName{jsval} could not be converted.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Conversion of boolean values]
bool cppValue = true;

// A) to jsval
jsval jsValue = BOOLEAN_TO_JSVAL(cppValue);

// B) from jsval - strict
if(JSVAL_IS_BOOLEAN(jsValue))
	cppValue = JSVAL_TO_BOOLEAN(jsValue)
else
	// error handling
	
// C) from jsval - using automatic conversion
if(!JS_ValueToBoolean(context, jsValue, &cppValue))
	// error handling
\end{lstlisting}
\OnehalfSpacing

\section{Number values}

\myProperName{ECMAScript} supports only a single number type. There is no distinction between integers and floating point values.\\
\myProperName{Spidermonkey} internally makes a difference and provides macros like \mySCName{JSVAL\_TO\_INTEGER}, which will result in an undefined result if the \mySCName{jsval} contains a double value. Thus, \myProperName{Spidermonkey} also provides generalized versions for converting between \myProperName{C++} types and the \myProperName{JavaScript} numbers, which should be used instead:

\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
	\item \mySCName{JS\_NewNumberValue}: creates a number \mySCName{jsval} from integer or floating point value
	\item \mySCName{JSVAL\_IS\_NUMBER}
	\item \mySCName{JS\_ValueToNumber}: converts to \mySCName{double}
	\item \mySCName{JS\_ValueToECMAInt32}
	\item \mySCName{JS\_ValueToECMAUint32}
	\item \mySCName{JS\_ValueToUint16}
	\end{itemize}

When converting to integers, the number value is rounded according to the \myProperName{ECMAScript} standard.

Usage of these macros and functions is similar to converting boolean values.

\section{Strings}

\mySCName{STRING\_TO\_JSVAL}, \mySCName{JSVAL\_IS\_STRING}, \mySCName{JSVAL\_TO\_STRING} and \mySCName{JS\_ValueToString} (with automatic conversion) can be used for converting between \mySCName{jsval} and \mySCName{JSString}.

\myProperName{JavaScript} strings are sequences of 16 bit wide characters. In \myProperName{Spidermonkey} such a character is defined as a \mySCName{jschar} and \mySCName{JSString} is a sequence of \mySCName{jschar}s. A \mySCName{jschar} is UTF-16.

\mySCName{JSString}s can be converted to null-terminated \myProperName{C++} character arrays using \mySCName{JS\_EncodeString}. The caller is responsible for handling the created memory. \mySCName{JS\_NewStringCopyZ} can be used to convert a null-terminated character array to a \mySCName{JSString}.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Conversion of strings]
const char* cppStr = "This is a null-terminated string";

// A) to jsval
JSString* jsStrToScript = JS_NewStringCopyZ(context, cppStr);
if(!jsStrToScript)
	// error handling
jsval jsValue = STRING_TO_JSVAL(jsStrToScript);

// B) from jsval - using automatic conversion
JSString* jsStrFromScript = JS_ValueToString(context, jsValue);
if(!jsStrFromScript)
	// error handling
	
char* cppStrFromScript = JS_EncodeString(context, jsStrFromScript);
if(!cppStrFromScript)
	// error handling
	
// ... using the char* ...
// ...

// cleaning up
if(cppStrFromScript)
	delete[] cppStrFromScript;
\end{lstlisting}
\OnehalfSpacing

To handle \mySCName{std::string}, its \mySCName{c\_str} method needs to be used to retrieve a \mySCName{const char*}. \mySCName{std::string} can be constructed from character arrays.

\subsection{Unicode}

As \mySCName{jschar} is UTF-16, \mySCName{JSString}s can be created from and converted to 16-bit unicode strings.\\
\mySCName{JS\_NewUCStringCopyZ} creates a \mySCName{JSString} from an array of \mySCName{jschar}s, whereas \linebreak\mySCName{JS\_GetStringCharsZ} returns an array of \mySCName{jschar}s from a \mySCName{JSString}.

The \myProperName{JSAPI} user has to do the conversion from his unicode character type to \mySCName{jschar} and verse visa.\\
\myProperName{C++}'s wide character type \mySCName{wchar\_t} is not well suited for this task, as its size is compiler specific. It is allowed to be at least 8 bit. On \myProperName{VC++} it is 16 bit, on GCC even 32 bit.\\
\myProperName{C++11} introduces new character types for unicode characters: \mySCName{char16\_t} and \mySCName{char32\_t}. Having a fixed width, \mySCName{char16\_t} should be the same as a \mySCName{jschar} on all platforms and thus be best suited for conversion between unicode strings and \mySCName{JSString}.

\newpage
\section{Namespaces}

In \myProperName{C++} namespaces exist for grouping other elements. In \myProperName{JavaScript} the same task can be achieved by creating a hierarchy of \mySCName{JSObject} instances. \mySCName{JS\_DefineObject} can be used to define an object property on another object.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=A simple wrapper function]
namespace Outside {
	namespace Inside {
		// ... declare functions, classes, etc.
	}
}

// somewhere in the glue code ...
// defining jsOutside on the global object
JSObject* jsOutside = JS_DefineObject(context, 
                             globalObject, "Outside", NULL, NULL, 0);
if(!jsOutside)
	// error handling
else {
	// defining jsInside on jsOutside
	JSObject* jsInside = JS_DefineObject(context, 
                             jsOutside, "Inside", NULL, NULL, 0);
	if(!jsInside)
		// error handling
	else {
		// ... wrap content of "Inside": functions, classes, etc.
	}
}
\end{lstlisting}
\OnehalfSpacing

\section{Functions}
\label{sec:Functions}

Functions are generally wrapped with the help of wrapper functions of the function type \mySCName{JSNative}. The wrapper function has to convert the parameters from \myProperName{JavaScript} values to \myProperName{C++} values, call the wrapped function and convert its return value to a \myProperName{JavaScript} value. If errors occur (for example if parameters of wrong types have been passed) or exceptions are thrown somewhere in the called \myProperName{C++} code, these have to be handled and the function will return \mySCName{false} to indicate a pending \myProperName{JavaScript} exception.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=A simple wrapper function]
float getFloat(bool param1, int param2);

JSBool getFloat_wrapper(JSContext *cx, uintN argc, jsval *vp)
{
	if(argc < 2)
		// throw JS exception: not enough parameters (return false)

	// handling parameters
	jsval* args = JS_ARGV(cx, vp);

	bool param1;
	if(!JS_ValueToBoolean(cx, args[0], &param1))
		// throw JS exception: wrong parameter type (return false)
	
	int param2;
	if(!JS_ValueToNumber(cx, args[1], &param2))
		// throw JS exception: wrong parameter type (return false)

	// calling function
	try {	
		int cppResult = getFloat(param1, param2);
		
		// setting return value
		if(!JS_NewNumberValue(cx, cppResult, &JS_RVAL(cx, vp)))
			// throw JS exception: could not create return value
		
	} catch (...) {
		// forward C++ exception as JS exception and return false
	}

	// no errors occurred
	return true;
}
\end{lstlisting}
\OnehalfSpacing

\mySCName{JSNative} gets three arguments. The \mySCName{JSContext} of the current call, the number of passed arguments (\mySCName{argc}) and an array of \mySCName{jsval}s named \mySCName{vp}. \mySCName{vp} contains the execution context (the \mySCName{this}), the passed arguments and a \mySCName{jsval} for the return value. The execution context can be retrieved using \mySCName{JS\_THIS(cx, vp)}. \mySCName{JS\_ARGV(cx, vp)} returns a pointer to the first parameter \mySCName{jsval}. \mySCName{JS\_RVAL(cx, vp)} retrieves the \mySCName{jsval} that will be the return value of the function call.

Primitive types are converted as explained in the previous chapters. The conversion of class types is explained in \myRefSection{sec:StructsAndClasses}. \\
Primitive types, including strings, are immutable. As such functions that take a reference or pointer to an immutable type (e.g. \mySCName{int\&} or \mySCName{char[]}) and try to change the value of the parameter during the call (sometimes referred to as \mySlang{out-parameter}) will not effect the actual \myProperName{JavaScript} parameter. The wrapper functions of such procedures must be written differently and the call from script-side will need to pass a mutable type (e.g. a \mySCName{JSObject}) whose members refer to the immutable parameters.

The wrapper function needs to be defined on a \mySCName{JSObject} (e.g. the global object) so it can be used. There are multiple ways to do this, for example with \mySCName{JS\_DefineFunction}:

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Defining a function]
JSFunction* func = JS_DefineFunction(context, 
        someJSObject,      // the JSObject* to define on
        "getFloat",        // name of the function
        getFloat_Wrapper,  // wrapper function
        2,                 // number of expected arguments 
        JSPROP_ENUMERATE); // flags
        
if(!func)
	// error handling
\end{lstlisting}
\OnehalfSpacing


\subsection{Overloaded functions}
\label{sec:OverloadedFunctions}

\myProperName{JavaScript} does not support overloaded functions per se. Instead, a function can inspect the parameters it was called with and behave according to the number and types of parameters passed.

When wrapping overloaded functions, the wrapper function can decide on the function to call by checking the \mySCName{argc} argument for the number of parameters. For overloaded functions with the same number of parameters, it can check the type of parameter with the functions \myProperName{JSAPI} provides (e.g. \mySCName{JSVAL\_IS\_NUMBER}, etc.).

Problems can arise for functions that overload on a type that has the same representation in \myProperName{JavaScript}, for example \mySCName{float} and double. Given a number value, there is no way to decide on the right overload implementation in such a case.

\subsection{Default arguments}

Similar to overloaded functions, the number of actually passed parameters needs to be checked to decide on how many can be converted and passed to the \myProperName{C++} function.

It is open to debate what should happen if a wrong parameter type is passed for a parameter that has a default value. As a valid function call is technically possible, the wrong type could simply be ignored and the default value used. This silent fail may lead to unintended behaviour though and thus is highly questionable.

\section{Classes}
\label{sec:StructsAndClasses}

The wrapping of custom types and inheritance hierarchies comes with a lot of possible pitfalls.\\
\myProperName{C++} classes can be best mapped to \myProperName{JavaScript} constructor functions, as explained in \myRefSection{sec:JavaScript}. \myProperName{SpiderMonkey} provides the structure \mySCName{JSClass} and the function \myProperName{JS\_InitClass} for performing this task.

A \mySCName{JSClass} object contains the name of a class, some flags and a set of \mySlang{hooks} - functions that are called by the \myProperName{JavaScript} engine on specific events. One of these \mySlang{hooks} is the finalize operation, which will be called when a \mySCName{JSObject}, that was created from this class, is garbage collected. The most important flag to set on the \mySCName{JSClass} is \mySCName{JSCLASS\_HAS\_PRIVATE}, which allows the objects created from the class to have a private data field. This field of type \mySCName{void*} will be used to store the instances of a wrapped \myProperName{C++} class.\\
\mySCName{JS\_InitClass} creates a prototype \mySCName{JSObject} from a given \mySCName{JSClass} and defines functions and properties on it. It defines the \myProperName{JavaScript} constructor function on the given scope object. It takes a constructor \mySCName{JSNative}, which will be called, when instances are created in script via \mySCName{new}. It usually creates an instance of the wrapped \myProperName{C++} class and saves it as the private data.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Initializing a class, label=lst:InitClass]
void finalize(JSContext *cx, JSObject *obj)
{
	// called upon garbage collection
}

JSClass jsClass = {
	"SampleClassWrap",        // Name of the class
	JSCLASS_HAS_PRIVATE,  // Flags
	JS_PropertyStub,      // Default hooks
	JS_PropertyStub, 
	JS_PropertyStub, 
	JS_StrictPropertyStub,
	JS_EnumerateStub, 
	JS_ResolveStub, 
	JS_ConvertStub, 
	finalize              // finalize operation
};

JSObject* jsPrototype;

// called when instance created via new
JSBool constructor(JSContext *cx, uintN argc, jsval *vp)
{
	// create the JavaScript object
	JSObject* obj = JS_NewObject(cx, &jsClass, jsPrototype, NULL);
	if (!obj)
		// error handling
	else
	{
		// create instance of C++ class and save it as private data
		if(!JS_SetPrivate(cx, obj, new ::SampleClass()))
			// error handling
		else
			// set the object as the return value
			JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
	}
	
	return true;
}

// initializing the class on a given scope JSObject
jsPrototype = JS_InitClass(context, scope, 
			
		NULL,        // parent prototype
		&jsClass,    // the used JSClass
		constructor, // constructor function
		0,           // expected parameters of constructor
		NULL,        // instance properties
		NULL,        // instance functions
		NULL,        // static properties
		NULL         // static functions
	);
\end{lstlisting}
\OnehalfSpacing

\myRefListing{lst:InitClass} shows the initialization of the constructor function \mySCName{SampleClassWrap} along with its prototype. \mySCName{SampleClassWrap} wraps the \myProperName{C++} class \mySCName{SampleClass}. New instances can be created from script via \mySCName{new SampleClassWrap()}, which will lead to new instances of \mySCName{SampleClass} being created. The given code does not expose any members, as the call to \mySCName{JS\_InitClass} passes \mySCName{NULL} for all properties and functions.

\subsection{Private data}
\label{sec:PrivateData}

When wrapping member functions and fields, the according wrapper code needs to retrieve the instance of the \myProperName{C++} class from the \mySCName{this} \mySCName{JSObject}'s private data. Within a \mySCName{JSNative} the \mySCName{this} \mySCName{JSObject} can be retrieved using \mySCName{JS\_THIS\_OBJECT}.

As functions can be borrowed and execution context be forced in \myProperName{JavaScript}, there is no guarantee that the JSObject's private data contains an instance of the expected class. Thus type checking has to be performed to validate the correct type of the private data and convert it from the \mySCName{void*}. Calling instance functions on unchecked values can lead to crashes.

When saving an instance as a private data \mySCName{void} pointer, type information is \mySlang{lost} and cannot be retrieved - not even using RTTI and \mySCName{dynamic\_cast}. \myProperName{C++} itself gives us no means of checking the data to be of a specific type. Thus, for performing type checking, the \mySCName{JSObject} itself is checked, whether it is of a specific \mySCName{JSClass}. An object of class \mySCName{SampleClassWrap} is guaranteed to hold an instance of \mySCName{SampleClass} as its private data - and nothing else. \myProperName{Spidermonkey} provides two important functions for performing such type checks.\\
\mySCName{JS\_GetInstancePrivate} returns the private data of a \mySCName{JSObject}, but checks the object to be of a given \mySCName{JSClass}. If the check fails, it returns \mySCName{NULL}.\\
\mySCName{JS\_HasInstance} checks a \mySCName{JSObject} (to be precise: a \mySCName{jsval}), whether it is an instance of a given constructor function. The function checks the whole prototype chain and as such is better suited for inheritance.\\
If these checks succeed, a private data value can safely be converted to the correct \myProperName{C++} type using \mySCName{static\_cast}.

Another possible way of type checking is to save the type information along with the private data. Such a concept will be presented in \myRefSection{sec:GenericWrapper}.

\myProperName{SpiderMonkey} provides another way of storing private data. A \mySCName{JSClass} can be initialized to have a fixed number (between 0 and 255) of reserved slots for \mySCName{jsval}s. Though being subject to GC, these slots are not exposed so script and can be used for any purpose.

\subsection{Constructors}

As a constructor is just a \mySCName{JSNative}, parameters can be passed to it like to any other function. As explained in \myRefSection{sec:OverloadedFunctions}, the correct constructor implementation for creating the \myProperName{C++} instance can be chosen based on the number and types of arguments.

As can be seen in \myRefListing{lst:InitClass}, the constructor's task is to create a \mySCName{JSObject} instance that will be returned. The created \myProperName{C++} instance will be stored as the private data of the \mySCName{JSObject}.

\subsection{Wrapping existing instances}

Already existing instances of \myProperName{C++} classes that the user wants to access from script can be wrapped similarly to the creation within a constructor. A new \mySCName{JSObject} with the according \mySCName{JSClass} and prototype needs to be created and the existing instance stored as the private data.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Wrapping an instance]
SampleClass instance = new SampleClass();

JSObject* wrapObj = JS_NewObject(context, 
			&sampleClass_JSClass,           // JSClass
			 sampleClass_Prototype, NULL);  // Prototype JSObject
			 
if (!wrapObj)
	// error handling
else
{
	// store the instance
	if(!JS_SetPrivate(context, wrapObj, instance))
		// error handling
}

\end{lstlisting}
\OnehalfSpacing

\subsection{Member functions}

Wrapping of member functions works similar to the wrapping of free functions as explained in \myRefSection{sec:Functions}.

For the function call to work, the class instance needs to be retrieved from the private data of the \mySCName{this} \mySCName{JSObject} as explained in \myRefSection{sec:PrivateData}. Type checking has to be performed.

\subsection{Fields}

In \myProperName{C++}, data members (fields) are often not declared as \mySCName{public}, but will instead be accessed using getter and setter functions.

In both cases, either a \myProperName{JavaScript} value property or accessor property can be created. Depending what kind of property is chosen, the behaviour may be different.

Exposing getters and setters as properties (e.g. \mySCName{obj.setVal(x)} becomes \mySCName{obj.val = x}) will give the wrapped class a more natural feeling, when being used from the scripting language, as function call syntax is removed.

\subsubsection{Accessor properties}

\subsubsection{Value properties}

\subsection{Memory management}

garbage collection

\subsection{Caching}



\subsection{Inheritance}

multiple, class-based vs prototype-based

problems with overwritten functions

\subsection{Const}

Being a weakly typed language, \myProperName{JavaScript} has no notion of \mySCName{const} values. As such, \mySCName{const} class instances are wrapped as non-\mySCName{const}. This removes security, when passing the language border and may lead to wrapped instances being used in an unexpected or unintended fashion.

It is free to the \myProperName{JSAPI} user to only expose constant functions of a class.

It is also possible to save a \mySCName{const} state in the \mySCName{JSObject} itself. Wrapper functions could check this state. If it is \mySCName{true} and a non-\mySCName{const} member function is used, a \myProperName{JavaScript} exception could be thrown.\\
This concept is not feasible, when caching \mySCName{JSObject}s. If a \myProperName{C++} function returns an instance for which a cached \mySCName{JSObject} exists and sets its \mySCName{const} state to \mySCName{true}, then all other users that were previously using the \mySCName{JSObject} in a non-\mySCName{const} manner will suddenly receive exceptions. This has to do with the \mySCName{const} state being stored in the value (the object) instead of the variable.

\subsection{Static members}

Static data members and functions are wrapped similar to fields and functions. As they are static, they make no use of the \mySCName{this} object. When calling \mySCName{JS\_InitClass} static properties and functions can be passed. \myProperName{JavaScript} has no real concept of static members as there is no distinction between classes and instances. When declaring ''static'' properties using \mySCName{JS\_InitClass} these are simply defined on the created constructor function, so access to static members looks similar to \myProperName{C++}. Contrary to \myProperName{C++}, it is not possible to access a static member from within an instance using \mySCName{this} - static members always have to be accessed using the constructor function object.

\section{Global variables}

\section{Typedefs}

As one of the main purposes of typedefs is to assign a simple name for a \myProperName{C++} type to ease code writing, a typedef feature is less needed in weakly typed languages.

To achieve a typedef-like effect in \myProperName{JavaScript}, constructor functions can be defined as properties on multiple objects, even with different property names.\\
It has to be pointed out, that there is no equivalent of typedefs for primitive types (except for \mySCName{null} and \mySCName{undefined}, as they are a value and type at the same time).

\section{Function pointers and callbacks}

\SingleSpacing
\begin{lstlisting}[language=C++, caption=\myProperName{C++} function that takes a function pointer]
void someFunc(float (*funcPointer)(int));
\end{lstlisting}
\OnehalfSpacing

\myProperName{C++} functions that take function pointers, often referred to as callbacks, are a problematic topic.\\
Two cases need to be distinguished:
\begin{enumerate}
\item Passing \myProperName{C++} functions as callbacks
\item Passing script functions as callbacks
\end{enumerate}

\subsubsection{Passing C++ functions as callbacks}

The first case is unproblematic. A pointer to a \myProperName{C++} function can be wrapped inside a simple \mySCName{JSObject}, by casting the function pointer (function address) to a \mySCName{void} pointer and saving it as the private member of the \mySCName{JSObject}. The glue code for the function that takes the function pointer will retrieve the function pointer from the private data of the appropriate argument by casting it back to the appropriate function type.

\subsubsection{Passing script functions as callbacks}

When passing a \myProperName{JavaScript} function as a callback, a wrapper function that has the same function type as the pointer has to be created. This is the \myProperName{C++} function that will then be passed to the function that takes the function pointer. Inside, the \myProperName{C++} arguments must be converted to types that \myProperName{JavaScript} understands. The \myProperName{JavaScript} callback-function has to be called and its return value converted to the \myProperName{C++} type that the function type expects. Thus, such a wrapper function works the exact other way around than wrapper functions presented earlier in this chapter:

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Wrapper code for handling methods that take function pointers \#1]
float wrapper_callback(int param)
{
	// 1. convert param to JavaScript Number
	// 2. call the JavaScript function
	// 3. convert the return value from a JS Number to float
}

JSBool wrapper_someFunc(JSContext *cx, uintN argc, jsval *vp)
{
	// call someFunc
	someFunc(&wrapper_callback);
}
\end{lstlisting}
\OnehalfSpacing

This approach comes with one big problem, when calling \mySCName{someFunc} multiple times with different \myProperName{JavaScript} callbacks: As \mySCName{wrapper\_callback} is a simple \myProperName{C++} function created at compile-time, it has no notion of state and as such no information about which \myProperName{JavaScript} function to use as the callback.

One way around this, is to save the \myProperName{JavaScript} callback function passed to \linebreak\mySCName{wrapper\_someFunc} in a global variable, so it can be retrieved within \mySCName{wrapper\_callback}. This approach only works, when the callback is called during the execution of \mySCName{someFunc}. If it is called at a random point in program execution, \mySCName{wrapper\_callback} would use the last \myProperName{JavaScript} function that was saved in the global variable, which may not be the one the user intended to be called. Thus this work-around is highly suboptimal.

\textbf{Passing state information}

Without run-time function creation (more about that later), a function callback of the given form can not be resolved in any other way then the previously presented. To support calling \mySCName{someFunc} multiple times with different callbacks, state information needs to be provided. This is possible in two ways, both of which need modification of the original function and/or parameter declaration.

State information can be provided by extending \mySCName{someFunc} and the function type to take an additional \mySCName{void} pointer for user data. The script function is then passed as user data to \mySCName{someFunc}, which will use/save it along with the function pointer. The user data will be passed as the \mySCName{void} pointer to the \myProperName{C} callback function and as such can be used in \mySCName{wrapper\_callback} to retrieve the script function to call.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Wrapper code for handling methods that take function pointers \#2]
void someFunc(float (*funcPointer)(int, void*), void* data);

float wrapper_callback(int param, void* data)
{
	// 1. convert param to JavaScript Number
	// 2. retrieve JSFunction to call from data
	// 3. call the JavaScript function
	// 4. convert the return value from a JS Number to float
}

JSBool wrapper_someFunc(JSContext *cx, uintN argc, jsval *vp)
{
	// retrieve JSFunction* from vp
	jsval* args = JS_ARGV(cx, vp);
	void* funcPtr =  jsval_to_jsfunction(cx, args[0]);
	
	// call someFunc
	someFunc(&wrapper_callback, funcPtr);
}
\end{lstlisting}
\OnehalfSpacing

Another way to modify the original \mySCName{someFunc} is to let it take functors that contain state information instead of a function pointer. Instead of passing the \mySCName{JSFunction} as an additional \mySCName{void} pointer, it would be saved in the functor object.

Either way, passing state information demands modification of the original source code. This may prove to be impossible in cases where 3rd party libraries are used.

\textbf{Run-time function creation and closures}

\myProperName{C++11} allows the creation of functions at run-time with the help of lambda functions\footnote{\url{http://www.cprogramming.com/c++11/c++11-lambda-closures.html}}. Lamdba functions can capture state and thus seem to be capable of solving the given problem. This concept is also known as a closure and, as a side note, is very common in \myProperName{JavaScript}.
\\Unfortunately only state-less lamdba functions can be passed as function pointers. Lambda functions that capture state are only syntactic sugar for functors and as such can not be used to solve the given problem.

The only other way of creating functions at run-time is to create the machine-code itself at run-time. This, of course, requires assembly and is thus outside of portable \myProperName{C++}. With this method, the memory address of the \myProperName{JavaScript} function to call could simply be stored in the machine-code itself.

\textbf{libffi}\footnote{\url{http://sourceware.org/libffi/}} contains functionality for creating these types of closures at run-time. It is used by \myProperName{Mozilla}'s \myProperName{js-ctypes} for allowing \myProperName{JavaScript} functions to be passed as \myProperName{C} function pointers. \myProperName{Python}'s \myProperName{ctypes} uses it for the same reason. As the creation of closures is a highly machine-dependent operation it is indispensable to use a 3rd party like \myProperName{libffi}.

The creation of machine-code at run-time is the only way for completely supporting script functions as callbacks. It has the drawback of an additional library dependency and is also not supported on all platforms.

\section{Templates}

Templates are an advanced feature of \myProperName{C++} for writing classes that can use arbitrary types. As such, templates are not really needed in weakly typed dynamic languages like \myProperName{JavaScript}.

Templates are merely blueprints for classes (and functions) that are instantiated at compile-time with the given types. This happens either implicitly or or explicitly.\\
Being a compile-time feature, generic templated classes like \mySCName{std::vector<T>} cannot be wrapped and thus made usable from script with arbitrary types set for the template parameters (e.g. \mySCName{T}).\\
As template instantiations (e.g. \mySCName{std::vector<int>}) are normal classes, they can be wrapped like any other. This means that for any type that the \myProperName{Spidermonkey} user might want to use as a template parameter, the according template needs to be instantiated and wrapped in the glue code. Being individual classes, instantiated templates have no relationship to each other and as such each needs to be wrapped on its own.\\
Glue code can be shared, by using templated wrapper functions though: 

\SingleSpacing
\begin{lstlisting}[language=C++, caption=A templated JSNative]
template<T>
float getFloat(T param1);

template<T>
JSBool shared_getFloat_wrapper(JSContext *cx, uintN argc, jsval *vp)
{
	// code that uses T
}

JSFunction* func = JS_DefineFunction(context, someJSObject,
        "getFloat",             // name of the function
        getFloat_Wrapper<int>,  // wrapper function instantiation
        1, JSPROP_ENUMERATE);
\end{lstlisting}
\OnehalfSpacing

\section{Generic wrapper}
\label{sec:GenericWrapper}
Sometimes the user does not need class members to be exposed to script, but only wants to pass instances across the language border. The user might, f. ex. receive a wrapped instance from an exposed \myProperName{C++} function and pass it on to another \myProperName{C++} function, without using the \myProperName{JavaScript} object in between.

As no members are exposed, it is possible to use the same \mySCName{JSClass} for all kinds of instances. This generic wrapper will leave ownership to \myProperName{C++}.\\
Compared to the previously explained wrapping of classes, the \mySCName{JSClass} \mySCName{GenericWrapper} will not be bound to a specific type of private data and as such can not be used for type checking. Thus, type information needs to be stored along with the private data \mySCName{void*}.

There are several ways to do this, for example the \myProperName{C++} \mySCName{typeid}\todo{ref} operator, which returns the type information of a given value. Though \mySCName{type\_info}s can be compared, they have no knowledge about inheritance chains.\\
There is a proposal to support rich pointers\todo{ref} (pointers that also contain type information) in \mySCName{C++}, but it is uncertain if the idea of rich pointers will ever become part some \myProperName{C++} standard.

During research I came across \myAuthorName{Cassio Neri}'s concept of an \mySCName{any\_ptr} - a class that holds a pointer and its type information. \mySCName{any\_ptr} allows casting up and down in inheritance chains at run-time without the possibility of crashes. If an \mySCName{any\_ptr} cannot be casted to a given type, its cast function simply returns \mySCName{NULL}. An important feature is its support for classes without RTTI.

\begin{lstlisting}[language=C++, caption=Implementation of \mySCName{any\_ptr}]
class any_ptr {
    void* ptr_;
    void (*thr_)(void*);
 
    template <typename T>
    static void thrower(void* ptr) { throw static_cast<T*>(ptr); }
 
public:
    template <typename T>
    any_ptr(T* ptr) : ptr_(ptr), thr_(&thrower<T>) {}
 
    template <typename U>
    U* cast() const {
        try { thr_(ptr_); }
        catch (U* ptr) { return static_cast<U*>(ptr); }
        catch (...) {}
        return 0;
    }
};

std::string str;
any_ptr anyPtr(&str); // T is deduced from &str

std::string* strPtr = anyPtr.cast<std::string>(); // --> points to str
std::exception* ePtr = anyPtr.cast<std::exception>(); // --> NULL
\end{lstlisting}
\OnehalfSpacing

The concept is simple, but clever. Along with the pointer, the \mySCName{any\_ptr} stores the address of a template function instantiation (\mySCName{thrower}) that was instantiated with the known type of the pointer (e.g. \mySCName{std::string}). This function does nothing but throw the pointer as an exception. The \mySCName{cast} function is another template function that takes the type that the pointer should be casted to as the template parameter \mySCName{U} (for example \mySCName{std::string} or \mySCName{std::exception}, \mySCName{int}, etc.). This type will be used in a catch clause to catch the pointer that was thrown in \mySCName{thrower}. If the \mySCName{catch} clause can catch the exception the cast is successful and the casted pointer returned. Otherwise \mySCName{NULL} is returned. Catching a \mySCName{U*} will also catch any subclass of the type used for \mySCName{U}.

Instead of storing the instance pointer directly, \mySCName{GenericWrapper} will store an instance of \mySCName{any\_ptr}, which was created with \mySCName{new any\_ptr(instancePtr)}. 

Using the run-time exception system is surely less performant and storing an \mySCName{any\_ptr} as the private data adds one level of indirection compared to storing the instance pointer itself. Nevertheless, \mySCName{any\_ptr} seems to be the only type-safe way of casting unknown private data.

As \myProperName{C++} holds ownership, the generic wrapper should not be used for wrapping function return values that are copies, as the memory will be leaked.

\section{Error handling}
\label{sec:ErrorHandling}

Errors can occur in a lot of places. Converting of a parameter to the expected type might fail. The \myProperName{C++} code that is called may throw an exception.

The \myProperName{JavaScript} engine does not automatically handle exceptions. The \myProperName{JSAPI} user has to do this himself at the language border - meaning the glue code and the wrapper functions. When a wrapper function returns \mySCName{false}, it tells the virtual machine that an error occurred and an exception has been set. Setting exceptions can be done using \mySCName{JS\_ReportError}:

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Error handling at the language border]
JSBool some_wrapper(JSContext *cx, uintN argc, jsval *vp)
{
	try {
		// code that throws exception
		
	} catch(std::exception& e) {
		JS_ReportError(cx, e.what());
		return false;
	} catch(...) {
		JS_ReportError(cx, "some_wrapper: An unknown exception occurred");
		return false;
	}
	
	// no errors detected
	return true;
}
\end{lstlisting}
\OnehalfSpacing