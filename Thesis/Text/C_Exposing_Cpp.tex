\chapter{Language binding between C++ and Spidermonkey}
\label{chap:LanguageBindingCPPJS}

\section{Items}

Overview C++ and Javascript

\subsection{Fundamental types}

\subsection{Functions}

\subsubsection{Overloaded functions}

\subsubsection{Default arguments}

\subsection{Structs and classes}

\subsubsection{Inheritence}

multiple, class-based vs prototype-based

\subsubsection{Const}

\subsubsection{Static members}

\subsection{Namespaces}

\subsection{Unions}

\subsection{Function pointers and callbacks}

\SingleSpacing
\begin{lstlisting}[language=C++, caption=C++ function that takes a function pointer]
void someFunc(float (*funcPointer)(int));
\end{lstlisting}
\OnehalfSpacing

C++ functions that take function pointers, often referred to as callbacks, are a problematic topic.\\
Two cases need to be distinguished:
\begin{enumerate}
\item Passing C++ functions as callbacks
\item Passing script functions as callbacks
\end{enumerate}

\subsubsection{Passing C++ functions as callbacks}

The first case is unproblematic. A pointer to a C++ function can be wrapped inside a simple JSObject, by casting the function pointer (function address) to a void pointer and saving it as the private member of the JSObject. The glue code for the function that takes the function pointer will retrieve the function pointer from the private data of the appropriate argument by casting it back to the appropriate function type.

\subsubsection{Passing script functions as callbacks}

When passing a JavaScript function as a callback, a wrapper function that has the same function type as the pointer has to be created. This is the C++ function that will then be passed to the function that takes the function pointer. Inside, the C++ arguments must be converted to types that JavaScript understands. The JavaScript callback-function has to be called and its return value converted to the C++ type that the function type expects. Thus, such a wrapper function works the exact other way around than wrapper functions presented earlier in this chapter:

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Wrapper code for handling methods that take function pointers \#1]
float wrapper_callback(int param)
{
	// 1. convert param to JavaScript Number
	// 2. call the JavaScript function
	// 3. convert the return value from a JS Number to float
}

JSBool wrapper_someFunc(JSContext *cx, uintN argc, jsval *vp)
{
	// call someFunc
	someFunc(&wrapper_callback);
}
\end{lstlisting}
\OnehalfSpacing

This approach comes with one big problem, when calling \mySCName{someFunc} multiple times with different JavaScript callbacks: As \mySCName{wrapper\_callback} is a simple C++ function created at compile-time, it has no notion of state and as such no information about which JavaScript function to use as the callback.

One way around this, is to save the JS callback function passed to \mySCName{wrapper\_someFunc} in a global variable, so it can be retrieved within \mySCName{wrapper\_callback}. This approach only works, when the callback is called during the execution of \mySCName{someFunc}. If it is called at a random point in program execution, \mySCName{wrapper\_callback} would use the last JS function that was saved in the global variable, which may not be the one the user intended to be called. Thus this work-around is highly suboptimal.

\textbf{Passing state information}

Without run-time function creation (more about that later), a function callback of the given form can not be resolved in any other way then the previously presented. To support calling \mySCName{someFunc} multiple times with different callbacks, state information needs to be provided. This is possible in two ways, both of which need modification of the original function and/or parameter declaration.

State information can be provided by extending \mySCName{someFunc} and the function type to take an additional void pointer for user data. The script function is then passed as user data to \mySCName{someFunc}, which will use/save it along with the function pointer. The user data will be passed as the void pointer to the C callback function and as such can be used in \mySCName{wrapper\_callback} to retrieve the script function to call.

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Wrapper code for handling methods that take function pointers \#2]
void someFunc(float (*funcPointer)(int, void*), void* data);

float wrapper_callback(int param, void* data)
{
	// 1. convert param to JavaScript Number
	// 2. retrieve JSFunction to call from data
	// 3. call the JavaScript function
	// 4. convert the return value from a JS Number to float
}

JSBool wrapper_someFunc(JSContext *cx, uintN argc, jsval *vp)
{
	// retrieve JSFunction* from vp
	jsval* args = JS_ARGV(cx, vp);
	void* funcPtr =  jsval_to_jsfunction(cx, args[0]);
	
	// call someFunc
	someFunc(&wrapper_callback, funcPtr);
}
\end{lstlisting}
\OnehalfSpacing

Another way to modify the original \mySCName{someFunc} is to let it take functors that contain state information instead of a function pointer. Instead of passing the JSFunction as an additional void pointer, it would be saved in the functor object.

Either way, passing state information demands modification of the original source code. This may prove to be impossible in cases where 3rd party libraries are used.

\textbf{Run-time function creation and closures}

C++11 allows the creation of functions at run-time with the help of lambda functions\todo{ref}. Lamdba functions can capture state and thus seem to be capable of solving the given problem. This concept is also known as a closure and, as a side note, is very common in JavaScript.
\\Unfortunately only state-less lamdba functions can be passed as function pointers. Lambda functions that capture state are only syntactic sugar for functors and as such can not be used to solve the given problem.

The only other way of creating functions at run-time is to create the machine-code itself at run-time. This, of course, requires assembly and is thus outside of portable C++. With this method, the memory address of the JavaScript function to call could simply be stored in the machine-code itself.

\textbf{libffi}\todo{ref} contains functionality for creating these types of closures at run-time. It is used by Mozilla's \textbf{js-ctypes} for allowing JavaScript functions to be passed as C function pointers. Python's \textbf{ctypes} uses it for the same reason. As the creation of closures is a highly machine-dependent operation it is indispensable to use a 3rd party like libffi.

The creation of machine-code at run-time is the only way for completely supporting script functions as callbacks. It has the drawback of an additional library dependency and is also not supported on all platforms.

\subsection{Templates}

\subsection{Modules}

\subsection{Properties}








\todo{TODO-List}
 - welche Sprachkonstrukte von C++ kann man auf andere Sprachen abbilden? 
 -- Klassen, Interfaces, virtuelle Methoden, Polymorphie, statische Methoden, Templates
 - Wie sieht es aus mit Sprachkonstrukten, die in C++ nicht existieren bzw. kompliziert sind?
 -- Properties? Umwandlung von Gettern und settern? Funktoren, Funktionspointer
 -- Ãœbergang von klassen-basierter Vererbung (C++) zu Prototyp-basierter Vererbung (JS)
 - abstrahierung