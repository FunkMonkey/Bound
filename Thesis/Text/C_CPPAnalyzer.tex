\chapter{Analysing C++ code}
\label{chap:AnalysingCPP}

To retrieve information about elements declared in C++ header files a shared library called \textbf{CPPAnalyzer} was written in C++. The library uses \textbf{libclang} for parsing C++ files and accessing AST information. Internally a reduced syntax tree is built and exported as JSON (JavaScript Object Notation).\todo{explain json}

The library exposes its functionality in form of a C interface.

\todo{C++11 - auto and regex, tested on windows with VS 2010}

\section{libclang}

As explained in \todo{ref}, libclang is a C interface to Clang that can be used for accessing Clang's parsing functionality and internal AST.

\todo{explain AST stuff}

The two most important structs libclang provides, are CXCursor and CXType.
\\\textbf{CXCursor} represents a single node in the AST. It holds an enum constant (named kind) that identifies the kind of the AST node - whether it is a namespace, function declaration, class declaration, etc. It also saves information about the according Clang data in an array of void pointers.
\\\textbf{CXType} represents a C++ type. It holds the kind of the type, for example if it is a pointer, reference, builtin type (like int or float), record (class or struct), etc. Just like CXCursor, it also saves information about the Clang type representation.

More information about cursors and types can be retrieved using the functions libclang provides.
\\If the user, for example, wants to know if a member function is declared as ''virtual'', he will call \mySCName{clang\_isCXXMethodVirtual} and pass a cursor that represents a member function (e.g. with the kind \mySCName{CXCursor\_CXXMethod}) to it. \mySCName{clang\_getCursorType}, as another example, will return the type of a variable or parameter declaration as a CXType.

\mySCName{clang\_parseTranslationUnit} is the starting point for parsing C++ files. The function ''accepts a set of command-line arguments so that the compilation can be configured in the same way that the compiler is configured on the command line''\todo{ref}. These options commonly contain the path to the file to be parsed. The function returns a translation unit, which holds all the AST information and is also the root cursor of the AST. While parsing, Clang produces diagnostic information, for example when mal-formed C++ code was provided or other errors occur. libclang provides functionality to access these diagnostics.

To traverse the abstract syntax tree (recursively), \mySCName{clang\_visitChildren} is used. As arguments, it takes the cursor to be visited, a function pointer, which serves as a callback that is called for every child, and a void pointer for user data. The callback function will be called from Clang, passing the visited cursor, its parent and the user data as parameters. The callback function is normally used to inspect and analyse the given cursor. The return value of the function tells Clang, if it should go on recursively with the first child of the cursor, go on with the next sibling or if it should end traversing of the AST at this point.

libclang provides more than 50 functions that deal with AST inspection - far too much, to be covered in this thesis. A complete overview is given at the libclang doxygen documentation.\footnote{\url{http://clang.llvm.org/doxygen/group\_\_CINDEX.html}}

\subsection{Extending libclang}

libclang does not expose all of the functionality Clang provides. Functionality missing in libclang is added on a per-need basis. 

During this thesis it became clear that libclang needs to be extended by the author to expose AST information about C++ templates. It seems, such information was not needed by other libclang users. The changes made to the libclang source code base will hopefully make its way back into the official Clang repository.

Most of the functions added to libclang simply forward Clang's internals. Still, the Clang code base needed to be understood and used in a safe\todo{word} fashion.

When turning Clang types into CXTypes, certain C++ types were not exposed. libclang was altered to support template type parameter types (TemplateTypeParm), template specialization types and elaborated types (types that are sugared with a type keyword like ''class'' and/or a prefixed namespace identifier):

\SingleSpacing
\begin{lstlisting}[language=C++, caption=Examples of types now supported by libclang]
template<class T>
class TemplatedClass
{
	// NEW: type of kind TemplateTypeParm
	T member; 
};

// NEW: type of kind TemplateSpecialization
TemplatedClass<int> tempSpecInstance; 

namespace SomeNamespace
{	
	class NormalClass{};
	
	// OLD: type of kind Record
	NormalClass instance;
	
	// NEW: type of kind Elaborated
	class NormalClass elaboratedInstance1;
}

// NEW: type of kind Elaborated
SomeNamespace::NormalClass elaboratedInstance2; 
\end{lstlisting}
\OnehalfSpacing

libclang already exposed template parameters as CXCursors when visiting the children of a class, struct or function cursor. Helper functions for accessing the template parameters directly from a template-supporting cursor, were added to libclang:

\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
\item unsigned clang\_getTemplateNumParameters(CXCursor C);
\item CXCursor clang\_getTemplateParameter(CXCursor C, unsigned Index);
\end{itemize}

libclang did not expose any information about template arguments. Template arguments are the actual types used for template parameters, when instantiating a template. Functions for retrieving template arguments and their values (as type, integral, etc.) were added:

\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
\item Added cursor kinds\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
	\item CXCursor\_TemplateNullArgument
	\item CXCursor\_TemplateTypeArgument
	\item CXCursor\_TemplateDeclarationArgument
	\item CXCursor\_TemplateIntegralArgument
	\item CXCursor\_TemplateTemplateArgument
	\item CXCursor\_TemplateTemplateExpansionArgument
	\item CXCursor\_TemplateExpressionArgument
	\item CXCursor\_TemplatePackArgument
	\end{itemize}
\item Added functions\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
	\item unsigned clang\_isTemplateArgument(CXCursor C);
	\item unsigned clang\_getTemplateSpecializationNumArguments(CXCursor C);
	\item CXCursor clang\_getTemplateSpecializationArgument(CXCursor C, unsigned Index);
	\item CXType clang\_getTemplateArgumentValueAsType(CXCursor C);
	\item long long clang\_getTemplateArgumentValueAsIntegral(CXCursor C);
	\item CXCursor clang\_getTemplateArgumentValueAsDeclaration(CXCursor C);
	\item CXCursor clang\_getTemplateArgumentValueAsTemplate(CXCursor C);
	\item CXCursor clang\_getTemplateArgumentValueAsExpression(CXCursor C);
	\end{itemize}
\end{itemize}

Also a utility function for retrieving the access (private, protected or public) of a C++ member field/function/subclass was added:
\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
\item CX\_CXXAccessSpecifier clang\_getCXXMemberAccessSpecifier(CXCursor)
\end{itemize}

Before, access needed to be tracked while analysing a class/struct cursor's children, by finding special child cursors that represent the C++ access specifiers.

\section{Building a simplified AST}

\section{Exporting AST to JSON}

\section{libclang and the C++ standard library}
