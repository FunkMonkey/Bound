Agenda
------

1. Klärung Formalitäten: Umfang der Arbeit, "Wissenschaftlichkeit", etc.
2. grobe Formulierung der Aufgabenstellung / Ziele
3. Diskussion (inkl. Brainstorming)
3.1 Aufbau und Themenüberblick der theoretischen Arbeit
3.2 Ziele und Funktionalitäten der praktischen Arbeit (Applikation)
4. Rückblick auf Formulierung der Aufgabenstellung / Ziele + ggf. Anpassung

Grobe Gedanken
--------------

1. Theorie-Teil
1.1 Zu bearbeitende Themen
1.1.1 Language-Binding

  - Was sind Skriptsprachen und warum erweitert man z. B. C++ durch diese?
  - Wie funktioniert Language-Binding (Wrapping, Glue-Code)
  - Welche Systeme / Methoden / Tools gibt es schon um Language-Binding zu vereinfachen / automatisieren (COM, Corba, Mozilla XPCOM + IDL, SWIG)
  - Warum wird ein eigenes Tool entwickelt? (Notwendigkeit, Vorteile, Goals- und Non-Goals, etc.)
  - Wie soll die Automatisierung grob erfolgen? -> Übergang zu Static Analysis
  
1.1.2 Static Analysis

 - Was ist Static Analysis?
 - Wie soll Static Analysis innerhalb des Projektes genutzt werden?
 -- -> Erhebung von Typ- und Member-Informationen zur weiteren Verarbeitung
 - Welche anderen Möglichkeiten gibt es die notwendigen Informationen zu erhalten und warum werden diese nicht genutzt? (Header-Parser, GCC-XML)
 - Welche Static Analysis Tools gibt es, warum kommen bzw. kommen sie nicht für die Erfüllung der Aufgabe in Frage
 - Begründung der Auswahl und Beschreibung des/der Systeme: (steht selbst für mich noch nicht fest)
 -- Dehydra (GCC-Plugin), *Linux only*
 -- Clang (LLVM-Compiler)
 - Wie erfüllt das gewählte System die Aufgabe?
 
1.1.3 Abbildung von C++ auf verschiedene Skriptsprachen

 - welche Sprachkonstrukte von C++ kann man auf andere Sprachen abbilden? 
 -- Klassen, Interfaces, virtuelle Methoden, Polymorphie, statische Methoden, Templates
 - Wie sieht es aus mit Sprachkonstrukten, die in C++ nicht existieren bzw. kompliziert sind?
 -- Properties? Umwandlung von Gettern und settern? Funktoren, Funktionspointer
 -- Übergang von klassen-basierter Vererbung (C++) zu Prototyp-basierter Vererbung (JS)
 
1.1.4 C++-Meta-Data zur Unterstützung der Auswahl (Intents) (optional)

 - kann der User schon im C++-Code Empfehlungen für die Art des Wrappings hinterlegen?
 - Wie? Makros? C++-Attribute?
 
1.1.5 Weitere Nutzungsmöglichkeiten eines solchen Systems? Meta-Data-Editor?
 
2. Praxis-Teil

 - Grobes Konzept: GUI-Applikation, die StaticAnalysis-Tool für C++ aufruft, welches Informationen (Typen und Member) in Datei speichert, die dann von GUI-Applikation gelesen wird
 
 - Welches Tool: Dehydra, libClang oder beides?
 -- Dehydra unter Windows mit VM und NodeJS?
 -- "Cehydra": eigene libClang-basierte C++-Applikation mit JS als Skriptsprache (Dehydra-kompatibel)? JS-Anbindung am Ende selbst über die entwickelte Applikation?
 -- Format der Informations-Datei:
 --- allgemein genug  als dass auch eine andere Sprache (z. B. C#) als Input-Sprache genutzt werden kann?
 
 - unterstützte Sprachen für Output: Javascript, Python, SWIG-Header

 - Verbindung von C++-Informationen und gewünschten Skript-Objekten
 -- 1:1-Abbildung (mit Auswahl)?
 -- beliebiger Aufbau in Skriptsprache (Skript-Objekt-Tree) mit durch User gesetzter Verbindung zu C++?
 
 - Wrapping von Klassen und einzelnen Objekten (u. A. Frage der Anbindung des Output)
 - Wrapping von 3rd-Party-Code? Std, etc...
 
 - Aufbau einer Projekt-Datei
 - Wie stark anpassbar? Wie weit kann der User selbst eingreifen und Code hinzufügen?
 
 - Beispiel-Projekte
  
 - Unterstützung von Intents?


