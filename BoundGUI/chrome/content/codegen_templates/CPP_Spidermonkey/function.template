{
	"description":
	"(String)  wrapperFunctionName: name of the wrapper-function
	(String)  parentQualifier: full name of parent (with namespaces and class name)
	(String)  cppFuncionName        : name of the function to call

	(boolean) isInstanceCall  : true if it is a call to a function of an instance, otherwise false

	(String)  params : Array of parameter information (holding initCode and name)
	(String)  call_parameters : parameter names given to the function (comma-separated list)
	(String)  returnCode      : code for setting the resturn value

	(String)  error_source    : source name that will be part of the error message",
	
"includes": ["#include \"{$cpp_spidermonkey_lib_include_dir}wrap_helpers/wrap_helpers_x.hpp\""],
	
"templateCode":
"JSBool {$wrapperFunctionName}(JSContext *cx, uintN argc, jsval *vp)
{
	JSWRAP_TRY_START
	
{if $isInstanceCall}		{$parentQualifier}& inst = getThisPrivateRef<{$parentQualifier}>(cx, vp);
		
{/if}{if $numParams > 0}
		checkMinNumberOfArguments_x(argc, {$numParams});
		jsval* args = JS_ARGV(cx, vp);

{/if}{$paramsInit|indent:2:\"\\t\"}
		{if $returnType.cppTypeStr}{$returnType.cppTypeStr} cpp__result = {/if}{if $isInstanceCall}inst.{else}{$parentQualifier}::{/if}{$cppFuncionName}({$callParamList});
	
		{$returnType.code}
	JSWRAP_CATCH_AND_REPORT_JS_ERROR(cx, \"{$errorSource}\")
	
	return true;
}",

"onFetchBefore": ["data", "
		data.paramsInit = '';
		data.callParamList = '';
		for(var i = 0, end = data.params.length; i != end; ++i)
		{
			data.paramsInit += data.params[i].initCode + '\\n';
			data.callParamList += data.params[i].name;
		
			if(i != (end-1))
				data.callParamList += ', ';
		}
	"],

"functions": {
	"getParameter":	     ["index", "return 'args[' + index + ']';"],
	"getReturnJSVAL":    ["return 'JS_RVAL(cx, vp)';"],
	"getCPPReturnValue": ["return 'cpp__result';"]
}

}